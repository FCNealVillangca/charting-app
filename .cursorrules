# Cursor Rules for Charting App

## Backend Dependencies
- **SQLAlchemy** and **Alembic** are installed separately, NOT in requirements.txt
- Database: SQLite with SQLAlchemy ORM
- Install with: `pip install sqlalchemy alembic`

## Context State Management
- **NEVER** add new state to ChartContext unless absolutely necessary
- ChartContext should only contain state that needs to be shared across multiple components
- If only one component needs state, use local useState instead
- Before adding state to context, ask: "Do at least 2 different components need this state?"

## Component Architecture
- Keep components focused and single-purpose
- Use local state for component-specific data
- Only use context for truly global state that multiple components need
- **Dialog/Modal state should live in the dialog component itself** (e.g., `chart-timeframe-dialog.tsx` has its own open/close state)

## State Management Rules
- **NEVER add redundant state** - if data can be derived or computed, derive it
- **NEVER duplicate state** - if state exists elsewhere, use it directly or pass it down
- Before adding ANY new state, ask: "Can this be derived from existing state or props?"
- Prefer derived values using `useMemo` over creating new state variables
- If you find yourself syncing state between variables, you're doing it wrong - remove the duplicate
- **Challenge every state addition** - most of the time you don't need it
- **UI state (modals, dropdowns, tooltips) belongs in the UI component** - don't lift it up unless another component needs to control it

## Styling Rules
- **ALWAYS use Tailwind CSS classes** instead of inline styles
- Use `className` prop, not `style={{}}` prop
- Only use inline styles for dynamic values that can't be achieved with Tailwind
- Keep styling consistent with Tailwind's design system

## Debugging Approach
- When debugging issues, check component re-renders first
- Look for state that's being reset unnecessarily
- Check if the issue is in the component logic, not missing context state
